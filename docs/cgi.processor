syntax:

<(	open bracket
)>	close bracket

<(*	open bracket for comment
*)>	close bracket for comment

<(>	open bracket for non-parsing area
<)>	close bracket for non-parsing area

variables:
	variables begin with $
	example:
		1. $var
		2. $1var

	processor supports 4 types of variables:
		1. string
		2. array
		3. hash
		4. array of hashes
		
	variable is iterative with `for` loop
	variable member can be accessed directly with `.` operator
	example: 
		1. the first symbol of the string: $strVar.0
		2. the second element of the array: $arrVar.1
		3. the first symbol of the second element of the array: $arrVar.1.0
		4. the element named "one" of the hash: $hashVar.one
		5. the element named "one" of the second element in the array of the hashes: $hashArrVar.1.one

	variable can be used as a key to the member. it must be wrapped with '{}'
	example:
		1. element named "one" of the second element in array of hashes(variable 'varOne' has value "one"): $hashArrVar.1.{$varOne}
		2. element named "one" of the second element in array of hashes(array 'hashVar' has member "one" which value is "one"): $hashArrVar.1.{$hashVar.one}

	pairs of (", ', `) are removed from the statement: "$var" == '$var' == $var == `$var`

namespace:
	processor uses namespaces, variables have scope of visibility
	example:
		variable defined before the loop is avalaible after the loop with the statement it has before:
		<(for $b in $arr2)>
			<(for $b in $b)> <(* HERE : `$b in $b` and it's OK! *)>
				|<(print $b)>
			<(rof)>
			|<(print $b.one)>
		<(rof)>		

blocks:
	include:
		include external template file into current and process
		example:
			<(include $template)>

			<(include template.tpl)>
	
	if:
		`if` statement allows to use conditional blocks
		`fi` closes `if` block
		`else` block is processed when `if` statement is false
		`if` statement allows `==`,`!`,`!=` for strings and `==`, `!=`, `!`, `<=`,`>=`,`<`,`>` for numeric
		`!` inverts statement value
		`if` statement is false when the statement is false(for 2 arguments) or for one when the argument is 'false' or empty
		example:
			<(if $a == $b )>
				that's OK 1
			<(fi)>

			<(if $b )>
				that's OK 2
			<(fi)>

			<(if ! $a )>
				that's OK 3
			<(else)>
				smth else ...
			<(fi)>

	for:
		`for` statement allows to iterate through array/string
		`rof` closes `for` block
		`=>` operator is used to get pairs 'key=>value'
		in `for` statement `continue` and `break` blocks can be used
		`break` block may have a strength - how many loops[in deep] to break => <(break 2)> => breaks 2 loop blocks; if not specified - 1 by default
		`break` and `continue` blocks outside the loop blocks do nothing
		
		example:
			//c++ code:
			cgi::processor cgip;
			
			dodoStringArray arr;
			arr.push_back("one");
			arr.push_back("two");
			arr.push_back("three");
			cgip.assign("arr",arr);
			
			dodoStringMap arr1;
			arr1["one"] = "one";
			arr1["two"] = "two";
			arr1["three"] = "three";
			cgip.assign("arr1",arr1);
			
			dodoArray<dodoStringMap> arr2;
			arr2.push_back(arr1);
			arr1["one"] = "three";
			arr2.push_back(arr1);
			cgip.assign("arr2",arr2);
			
			//template
			<(for $b in $arr)>
				<div class="test"><(print $b)></div>
			<(rof)>

			<(for $c in $arr2.1)>
				|<(print $c)>
			<(rof)>

			<(for $c in $arr1)>
				|<(print $c)>
			<(rof)>
				
			<(for $b in $arr2)>
				<(for $b in $b)> <(* HERE : `$b in $b` and it's OK! *)>
					|<(print $b)>
				<(rof)>
				|<(print $b.one)>
			<(rof)>
			
			<(for $b in $arr2)>
				<(for $b => $c in $b)>
					<(print $b)> -> <(print $c)>
				<(rof)>
			<(rof)>
			
			<(for $b in $arr)>
				<(if $b==2 )>
					<(continue)>
				<(fi)>
				<(print !!!)>
				<(if $b==4 )>
					<(break)>
				<(fi)>
				<(print @@@)>
			<(rof)>
			
	print:
		print variable value
		values can me combined with ','
		example:
			<(print {$arr2.{0}.{$one}} )>
			
			<(print $arr2.1.{$arr1.{$one}} )>
			
			<(print $arr2.1.{$arr1.{$one}} , !!!! , {$arr2.{0}.{$one}})>
