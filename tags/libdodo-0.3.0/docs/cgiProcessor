cgiProcessor:

elements of syntax:

<(	open bracket
)>	close bracket

<(*	open bracket for comment
*)>	close bracket for comment

<(>	open bracket for non-parsing area
<)>	close bracket for non-parsing area

variables begins from $
examples: $var	$1var

possible 4 types of variable:
	1.string
	2.array
	3.hash
	4.array of hashes
	
you may itarate each or directly access to their members;
for example : 
			1.first symbol of string: $strVar.0
			2.second element of array: $arrVar.1
			3.first symbol of second element of array: $arrVar.1.0
			4.element named "one" of the hash: $hashVar.one
			5.element named "one" of the second element in array of hashes: $hashArrVar.1.one

as key to member of variable may be also variable, but it must be wrapped with '{}'
for example :
			1.element named "one" of the second element in array of hashes, variable 'varOne' has value "one" : $hashArrVar.1.{$varOne}
			2.element named "one" of the second element in array of hashes, member "one" of the array 'arrVar' has value "one": $hashArrVar.1.{$arrVar.one}

pair of (", ', `) will be removed from the statement, so "$var" == '$var' == $var == `$var`

namespace:
	cgiProcessor uses namespaces.
	for examle:
		variable define before loop is avalaible after loop
		<(for $b in $arr2)>
			<(for $b in $b)> <(* HERE : `$b in $b` and it's OK! *)>
				|<(print $b)>
			<(rof)>
			|<(print $b.one)>
		<(rof)>		

blocks:
	include:
		<(include $template)>

		<(include template.tpl)>

		includes external template file into current and processes

	
	if:
		<(if $a == $b )>
			that's OK 1
		<(fi)>

		<(if $b )>
			that's OK 2
		<(fi)>

		<(if ! $a )>
			that's OK 3
		<(else)>
			smth else ...
		<(fi)>

		`if` statement allows `==`,`!`,`!=` for strings and `<=`,`>=`,`<`,`>` for floats(converts from strings)

		`if` statement is false if statement is false(for 2 arguments) or if argument == false(string) or empty(for 1 argument)
	
	for:
		/**
		c++ code:
		*/
				cgiProcessor cgip;
				
				stringArr arr;
				arr.push_back("one");
				arr.push_back("two");
				arr.push_back("three");
				cgip.assign("arr",arr);
				
				assocArr arr1;
				arr1["one"] = "one";
				arr1["two"] = "two";
				arr1["three"] = "three";
				cgip.assign("arr1",arr1);
				
				std::vector<assocArr> arr2;
				arr2.push_back(arr1);
				arr1["one"] = "three";
				arr2.push_back(arr1);
				cgip.assign("arr2",arr2);
		
		/**
		template
		*/			
			<(for $b in $arr)>
				<div class="test"><(print $b)></div>
			<(rof)>

			<(for $c in $arr2.1)>
				|<(print $c)>
			<(rof)>

			<(for $c in $arr1)>
				|<(print $c)>
			<(rof)>
				
			<(for $b in $arr2)>
				<(for $b in $b)> <(* HERE : `$b in $b` and it's OK! *)>
					|<(print $b)>
				<(rof)>
				|<(print $b.one)>
			<(rof)>
			
			<(for $b in $arr2)>
				<(for $b => $c in $b)>
					<(print $b)> -> <(print $c)>
				<(rof)>
			<(rof)>
			
			`for` statement allows to iterate through array. to get pair 'key=>value' use `=>` operator(see an example).	
			in `for` statement you may use `continue` and `break` blocks: 
			
			<(for $b in $arr)>
				<(if $b==2 )>
					<(continue)>
				<(fi)>
				<(print !!!)>
				<(if $b==4 )>
					<(break)>
				<(fi)>
				<(print @@@)>
			<(rof)>
			`break` block may have a strenght - how many loops[in deep] to break => <(break 2)> => breaks 2 loop blocks; if not specified - 1 by default
			`break` and `continue` statements outside loop blocks do nothing
			
		print:
			<(print {$arr2.{0}.{$one}} )>
			
			<(print $arr2.1.{$arr1.{$one}} )>
			
			you	may combine some values using ',':
			<(print $arr2.1.{$arr1.{$one}} , !!!! , {$arr2.{0}.{$one}})>