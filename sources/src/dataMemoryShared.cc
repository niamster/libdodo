/***************************************************************************
 *            sh.dataMemoryShared.cc
 *
 *  Wed Nov 21 2007
 *  Copyright  2007  Dmytro Milinevskyy
 *  milinevskyy@gmail.com
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 2.1 as published by
 *  the Free Software Foundation;
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/**
 * vim indentation settings
 * set tabstop=4
 * set shiftwidth=4
 */

#include <libdodo/directives.h>

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <string.h>
#ifdef XSI_IPC
#include <sys/ipc.h>
#include <sys/shm.h>
#endif
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>

#include <libdodo/dataMemoryShared.h>
#include <libdodo/toolsMisc.h>
#include <libdodo/types.h>
#include <libdodo/toolsCode.h>
#include <libdodo/dataMemorySharedEx.h>

namespace dodo {
    namespace data {
        namespace memory {
            /**
             * @struct __key__
             * @brief defines shared memory key
             */
            struct __key__ {
#ifdef XSI_IPC
                int        key;             ///< key for the shared sh.data
#else
                dodo::string key;             ///< key for the shared sh.data
#endif
            };
        };
    };
};

using namespace dodo::data::memory;

shared::__shared__::__shared__(void *data) : data(data)
{
}

//-------------------------------------------------------------------

shared::__shared__::__shared__() : data(NULL)
{
}

//-------------------------------------------------------------------

shared::shared(shared &)
{
}

//-------------------------------------------------------------------

shared::shared() : handle(-1),
                   sh(NULL),
                   key(new __key__),
                   autogenerated(false)
{
#ifndef XSI_IPC
    sh.size = 0;
#endif
}

//-------------------------------------------------------------------

shared::shared(int a_key) : handle(-1),
                            sh(NULL),
                            key(new __key__),
                            autogenerated(false)
{
#ifndef XSI_IPC
    sh.size = 0;
#endif

#ifdef XSI_IPC
    if (a_key == 0) {
        key->key = tools::misc::iRandom();

        autogenerated = true;
    } else {
        key->key = a_key;
    }
#else
#ifdef __FreeBSD__
    key->key = "/tmp/";
#else
    key->key = "/";
#endif

    if (a_key == 0) {
        char _key[SH_KEY_SIZE / 2 - 1];
        tools::misc::random(_key, SH_KEY_SIZE / 2 - 1);

        key->key += dodo::string(tools::code::binToHex(dodo::string(_key, SH_KEY_SIZE / 2 - 1)));

        autogenerated = true;
    } else {
        char _key[4];
        memcpy(_key, &a_key, 4);

        key->key += dodo::string(tools::code::binToHex(dodo::string(_key, 4)));
    }

    handle = shm_open(key->key.data(), O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
    if (handle == -1) {
        delete key;

        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_SHARED, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    }
#endif
}

//-------------------------------------------------------------------

shared::~shared()
{
#ifdef XSI_IPC
    if (handle != -1 && autogenerated)
        shmctl(handle, IPC_RMID, NULL);

#else
    if (handle != -1) {
        if (sh.data != NULL)
            munmap(sh.data, sh.size);

        if (autogenerated)
            shm_unlink(key->key.data());
    }
#endif

    delete key;
}

//-------------------------------------------------------------------

void
shared::open(int a_key) const
{
    close();

#ifdef XSI_IPC
    if (a_key == 0) {
        key->key = tools::misc::iRandom();

        autogenerated = true;
    } else {
        key->key = a_key;
    }
#else
#ifdef __FreeBSD__
    key->key = "/tmp/";
#else
    key->key = "/";
#endif

    if (a_key == 0) {
        char _key[SH_KEY_SIZE / 2 - 1];
        tools::misc::random(_key, SH_KEY_SIZE / 2 - 1);

        key->key += dodo::string(tools::code::binToHex(dodo::string(_key, SH_KEY_SIZE / 2 - 1)));

        autogenerated = true;
    } else {
        char _key[4];
        memcpy(_key, &a_key, 4);

        key->key += dodo::string(tools::code::binToHex(dodo::string(_key, 4)));
    }

    handle = shm_open(key->key.data(), O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
    if (handle == -1)
        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_OPEN, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

#endif
}

//-------------------------------------------------------------------

void
shared::close() const
{
#ifdef XSI_IPC
    if (handle != -1 && autogenerated)
        if (shmctl(handle, IPC_RMID, NULL) == -1)
            dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_CLOSE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

#else
    if (handle != -1) {
        if (sh.data != NULL)
            if (munmap(sh.data, sh.size) == -1)
                dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_CLOSE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

        if (autogenerated)
            if (shm_unlink(key->key.data()) == -1)
                dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_CLOSE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    }
#endif
}

//-------------------------------------------------------------------

void
shared::remove(int a_key)
{
#ifdef XSI_IPC
    int handle = shmget(a_key, 0, S_IRUSR | S_IWUSR);
    if (handle == -1)
        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_REMOVE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

    if (shmctl(handle, IPC_RMID, NULL) == -1)
        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_REMOVE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

#else
#ifdef __FreeBSD__
    dodo::string key = "/tmp/";
#else
    dodo::string key = "/";
#endif

    char _key[4];
    memcpy(_key, &a_key, 4);

    key += dodo::string(tools::code::binToHex(dodo::string(_key, 4)));

    if (shm_unlink(key.data()) == -1)
        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_REMOVE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

#endif
}

//-------------------------------------------------------------------

void *
shared::map(unsigned long a_size) const
{
    unmap();

#ifdef XSI_IPC
    if (a_size == 0) {
        handle = shmget(key->key, 0, S_IRUSR | S_IWUSR);
        if (handle == -1)
            dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_MAP, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    } else {
        handle = shmget(key->key, a_size, IPC_CREAT | S_IRUSR | S_IWUSR);
        if (handle == -1)
            dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_MAP, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    }

    sh.data = shmat(handle, NULL, 0);
    if (sh.data == (void *)-1) {
        sh.data = NULL;

        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_MAP, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    }
#else
    if (a_size == 0) {
        struct stat st;

        if (fstat(handle, &st) == -1)
            dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_MAP, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

        sh.size = st.st_size;
    } else {
        sh.size = a_size;
    }

    if (ftruncate(handle, sh.size) != 0)
        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_MAP, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

    sh.data = mmap(NULL, sh.size, PROT_READ | PROT_WRITE, MAP_SHARED, handle, 0);
    if (sh.data == MAP_FAILED)
        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_MAP, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

#endif

    return sh.data;
}

//-------------------------------------------------------------------

void
shared::unmap() const
{
    if (sh.data != NULL) {
#ifdef XSI_IPC
        if (shmdt(sh.data) == -1)
#else
        if (munmap(sh.data, sh.size) == -1)
#endif

            dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_UNMAP, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

        sh.data = NULL;
    }
}

//-------------------------------------------------------------------

void *
shared::data() const
{
    return sh.data ? sh.data : map();
}

//-------------------------------------------------------------------

unsigned long
shared::size() const
{
#ifdef XSI_IPC
    if (handle == -1) {
        handle = shmget(key->key, 0, S_IRUSR | S_IWUSR);
        if (handle == -1)
            dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_SIZE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    }

    struct shmid_ds ds;

    if (shmctl(handle, IPC_STAT, &ds) == -1)
        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_SIZE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

    return ds.shm_segsz;
#else
    struct stat st;

    if (fstat(handle, &st) == -1)
        dodo_throw exception::basic(exception::MODULE_DATAMEMORYSHARED, SHAREDEX_SIZE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

    return st.st_size;
#endif
}

//-------------------------------------------------------------------

