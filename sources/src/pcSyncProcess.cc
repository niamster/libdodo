/***************************************************************************
 *            pcSyncProcess.cc
 *
 *  Sun Jul 22 2007
 *  Copyright  2007  Ni@m
 *  niam.niam@gmail.com
 ****************************************************************************/

/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License version 2.1 as published by
 *  the Free Software Foundation;
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/**
 * vim indentation settings
 * set tabstop=4
 * set shiftwidth=4
 */

#include <libdodo/directives.h>

#ifdef XSI_IPC
#include <sys/ipc.h>
#include <sys/sem.h>
#else /*POSIX_LOCKS*/
#include <fcntl.h>
#include <semaphore.h>
#endif
#include <sys/stat.h>
#include <time.h>
#include <errno.h>
#include <string.h>

#include <libdodo/pcSyncProcess.h>
#include <libdodo/pcSyncProtector.h>
#include <libdodo/pcSyncProcessEx.h>
#include <libdodo/types.h>
#include <libdodo/toolsMisc.h>
#include <libdodo/toolsCode.h>

namespace dodo {
    namespace pc {
        namespace sync {
            /**
             * @struct process::__lock__
             * @brief defines system lock
             */
            struct process::__lock__ {
                /**
                 * constructor
                 */
                __lock__() :
#ifdef XSI_IPC
                    keeper(-1)
#else
                    keeper(NULL)
#endif
                {
                }

#ifdef XSI_IPC
                int        keeper;              ///< lock
                int        key;                 ///< key for the lock
                union semun {
                    int             val;
                    struct semid_ds *buf;
                    ushort          *array;
                } control;                      ///< lock lock->control structure

                sembuf     operations[1];       ///< lock lock->operations
#else
                sem_t      *keeper;             ///< lock
                dodoString key;                 ///< key for the lock
#endif
            };
        };
    };
};

using namespace dodo::pc::sync;

process::process(process &)
{
}

//-------------------------------------------------------------------

process::process(int a_key) : lock(new process::__lock__),
                              autogenerated(false),
                              recursive(0)

{
#ifdef XSI_IPC
    if (a_key == 0) {
        lock->key = tools::misc::iRandom();

        autogenerated = true;
    } else {
        lock->key = a_key;
    }

    lock->operations[0].sem_num = 0;
    lock->operations[0].sem_flg = 0;

    lock->keeper = semget(lock->key, 1, S_IRUSR | S_IWUSR | IPC_CREAT);
    if (lock->keeper == -1) {
        delete lock;

        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_CONSTRUCTOR, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    }

    lock->control.val = 1;

    if (semctl(lock->keeper, 0, SETVAL, lock->control) == -1) {
        delete lock;

        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_CONSTRUCTOR, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    }
#else
    lock->key = '/';

    if (a_key == 0) {
        char _key[SH_KEY_SIZE / 2 - 1];
        tools::misc::random(_key, SH_KEY_SIZE / 2 - 1);

        lock->key.append(tools::code::binToHex(dodoString(_key, SH_KEY_SIZE / 2 - 1)));

        autogenerated = true;
    } else {
        char _key[4];
        memcpy(_key, &a_key, 4);

        lock->key.append(tools::code::binToHex(dodoString(_key, 4)));
    }

    lock->keeper = sem_open(lock->key.data(), O_CREAT, S_IRUSR | S_IWUSR, 1);
    if (lock->keeper == SEM_FAILED) {
        delete lock;

        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_CONSTRUCTOR, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    }
#endif
}

//-------------------------------------------------------------------

process::~process()
{
#ifdef XSI_IPC
    try {
        if (acquired() && getpid() == current) {
            lock->operations[0].sem_op = 1;

            semop(lock->keeper, lock->operations, 1);
        }
    } catch (...) {
    }

    if (autogenerated)
        semctl(lock->keeper, 0, IPC_RMID);
#else
    try {
        if (acquired() && getpid() == current)
            sem_post(lock->keeper);
    } catch (...) {
    }

    sem_close(lock->keeper);

    if (autogenerated)
        sem_unlink(lock->key.data());
#endif

    delete lock;
}

//-------------------------------------------------------------------

void
process::remove(int a_key)
{
#ifdef XSI_IPC
    int keeper = semget(a_key, 1, S_IRUSR | S_IWUSR);
    if (keeper == -1)
        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_REMOVE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

    if (semctl(keeper, 0, IPC_RMID) == -1)
        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_REMOVE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
#else
    dodoString key = "/";

    char _key[4];
    memcpy(_key, &a_key, 4);

    key.append(tools::code::binToHex(dodoString(_key, 4)));

    if (sem_unlink(key.data()) == -1)
        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_REMOVE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
#endif
}

//-------------------------------------------------------------------

void
process::acquire(unsigned long microseconds)
{
    int pid = getpid();

    if (acquired() && pid == current) {
        ++recursive;

        return;
    }

#ifdef XSI_IPC
    if (microseconds == 0) {
        lock->operations[0].sem_op = -1;

        if (semop(lock->keeper, lock->operations, 1) != 0)
            throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    } else {
        bool locked = true;
        unsigned long slept = 0;

        lock->operations[0].sem_op = -1;
        lock->operations[0].sem_flg = IPC_NOWAIT;

        while (locked) {
            if (semop(lock->keeper, lock->operations, 1) != 0) {
                if (errno != EAGAIN) {
                    lock->operations[0].sem_flg = 0;

                    throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
                }

                if (usleep(1) == -1) {
                    lock->operations[0].sem_flg = 0;

                    throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
                }

                slept += 1;

                if (slept > microseconds) {
                    lock->operations[0].sem_flg = 0;

                    throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRE, exception::ERRNO_LIBDODO, PROCESSEX_CANNOTLOCK, PCSYNCPROCESSEX_CANNOTLOCK_STR, __LINE__, __FILE__);
                }
            } else {
                locked = false;
            }
        }
    }
#else
    if (microseconds == 0) {
        if (sem_wait(lock->keeper) != 0)
            throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
    } else {
        bool locked = true;
        unsigned long slept = 0;

        while (locked) {
            if (sem_trywait(lock->keeper) != 0) {
                if (errno != EAGAIN)
                    throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

                if (usleep(1) == -1)
                    throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);

                slept += 1;

                if (slept > microseconds)
                    throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRE, exception::ERRNO_LIBDODO, PROCESSEX_CANNOTLOCK, PCSYNCPROCESSEX_CANNOTLOCK_STR, __LINE__, __FILE__);
            } else {
                locked = false;
            }
        }
    }
#endif

    current = pid;
    recursive = 0;
}

//-------------------------------------------------------------------

void
process::release()
{
    if (acquired() && current == getpid() && recursive > 0) {
        --recursive;

        return;
    }

#ifdef XSI_IPC
    lock->operations[0].sem_op = 1;

    if (semop(lock->keeper, lock->operations, 1) != 0)
        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_RELEASE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
#else
    if (sem_post(lock->keeper) != 0)
        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_RELEASE, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
#endif

    current = 0;
}

//-------------------------------------------------------------------

bool
process::acquired()
{
    int value;

#ifdef XSI_IPC
    value = semctl(lock->keeper, 0, GETVAL, 0);
    if (value == -1)
        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRED, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
#else
    if (sem_getvalue(lock->keeper, &value) != 0)
        throw exception::basic(exception::MODULE_PCSYNCPROCESS, PROCESSEX_ACQUIRED, exception::ERRNO_ERRNO, errno, strerror(errno), __LINE__, __FILE__);
#endif

    return (value == 0);
}

//-------------------------------------------------------------------

